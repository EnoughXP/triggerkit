import fs from "node:fs"
import path from 'node:path';
import type { BuildExtension } from "@trigger.dev/build/extensions";
import type { Plugin, OnLoadResult } from "esbuild";
import type { CachedFile, FileWithFunctions, PluginOptions } from './types/index.js';

const VIRTUAL_MODULE_ID = 'virtual:triggerkit';
const NAMESPACE = 'triggerkit-namespace';


function triggerkit(options?: PluginOptions): BuildExtension {

  const resolvedOptions: Required<PluginOptions> = {
    includeDirs: options?.includeDirs || ["src/lib"],
    filePatterns: options?.filePatterns || [".ts", ".js"],
    exclude: options?.exclude || ["test.", "spec.", ".d.ts"],
  }

  // Keep track of file states for rebuilding
  const fileCache: Map<string, CachedFile> = new Map();
  const envCache: Record<string, string> = {};

  return {
    name: "triggerkit",

    onBuildStart: async (context) => {
      context.logger.log("Triggerkit extension starting!");

      // Clear the file cache to start fresh
      fileCache.clear();

      // Scan each folder for function files
      for (const includeDir of resolvedOptions.includeDirs) {
        const dirPath = path.resolve(context.workingDir, includeDir);

        // Check if the folder exists
        if (!fs.existsSync(dirPath)) {
          context.logger.warn(`Warning: Directory ${includeDir} does not exist, skipping`);
          continue;
        }

        // Scan the folder recursively
        await scanFolderForFunctions(
          dirPath,
          resolvedOptions.filePatterns,
          resolvedOptions.exclude,
          fileCache,
          context
        );
      }

      // Only proceed if we have files to process
      if (fileCache.size === 0) {
        context.logger.warn("No function files found, triggerkit will not be active");
        return;
      }

      context.logger.log(`Found ${fileCache.size} function files`);

      // Create and register an esbuild plugin
      const functionsPlugin: Plugin = {
        name: 'virtual-triggerkit-module',
        setup(build) {
          // Handle requests for our virtual module
          build.onResolve({ filter: new RegExp(`^${VIRTUAL_MODULE_ID}$`) }, () => {
            if (fileCache.size === 0) {
              return { errors: [{ text: 'No function files found' }] };
            }

            return {
              path: VIRTUAL_MODULE_ID,
              namespace: NAMESPACE
            };
          });

          // Handle loading the virtual module
          build.onLoad({ filter: /.*/, namespace: NAMESPACE }, async () => {
            if (fileCache.size === 0) {
              return { errors: [{ text: 'No function files found' }] };
            }

            // Generate a module that exports all functions from all files
            let moduleContent = '// Generated by triggerkit\n\n';

            // Add environment variables section
            const envVarNames = Object.keys(envCache);
            if (envVarNames.length > 0) {
              moduleContent += '// Environment variables\n';
              for (const varName of envVarNames) {
                moduleContent += `const ${varName} = process.env.${varName};\n`;
              }
              moduleContent += '\n';
            }

            // Group files by folder for better organization
            const filesByFolder: Record<string, Map<string, FileWithFunctions>> = {};

            // Organize files by folder
            for (const [filePath, cachedFile] of fileCache.entries()) {
              if (!cachedFile.content) continue;

              // Extract function names
              const functionNames = extractFunctionNames(cachedFile.content);
              if (functionNames.length === 0) continue;

              // Get the relative path from the working directory
              const relPath = path.relative(context.workingDir, filePath);
              // Get the directory for grouping
              const dirName = path.dirname(relPath);

              if (!filesByFolder[dirName]) {
                filesByFolder[dirName] = new Map();
              }

              filesByFolder[dirName].set(filePath, {
                path: filePath,
                relPath,
                functionNames
              });
            }

            // Import and export functions grouped by folder
            for (const [folder, files] of Object.entries(filesByFolder)) {
              moduleContent += `// Functions from ${folder}\n`;

              // Import all functions from each file in this folder
              for (const [_, fileInfo] of files.entries()) {
                if (fileInfo.functionNames.length === 0) continue;

                // Format the import path (without extension)
                const importPath = fileInfo.relPath.replace(/\.(ts|js)$/, '');
                const importNames = fileInfo.functionNames.join(', ');

                moduleContent += `import { ${importNames} } from '${importPath}';\n`;
              }

              // Export all functions from this folder
              const allFunctionsInFolder: string[] = [];
              for (const fileInfo of files.values()) {
                allFunctionsInFolder.push(...fileInfo.functionNames);
              }

              if (allFunctionsInFolder.length > 0) {
                moduleContent += `export { ${allFunctionsInFolder.join(', ')} };\n\n`;
              }
            }

            // Add functions object that contains all exports
            moduleContent += '// Functions object with all exports\n';
            moduleContent += 'export const functions = {\n';

            for (const folders of Object.values(filesByFolder)) {
              for (const fileInfo of folders.values()) {
                for (const funcName of fileInfo.functionNames) {
                  moduleContent += `  ${funcName},\n`;
                }
              }
            }

            moduleContent += '};\n';

            return {
              contents: moduleContent,
              loader: 'ts',
            } as OnLoadResult;
          });

          // Handle SvelteKit env imports
          build.onResolve({ filter: /^\$env\/static\/(public|private)$/ }, (args) => {
            return {
              path: args.path,
              namespace: 'sveltekit-env'
            };
          });

          // Provide virtual content for SvelteKit env modules
          build.onLoad({ filter: /.*/, namespace: 'sveltekit-env' }, (args) => {
            const isPublic = args.path.endsWith('public');
            const envType = isPublic ? 'public' : 'private';

            // Generate a module that exports environment variables from process.env
            let content = '// Generated SvelteKit environment module\n';
            content += '// This will use process.env variables at runtime\n\n';

            // For type checking, we'll export placeholder variables
            // The actual values will come from process.env at runtime
            if (isPublic) {
              content += '// Public environment variables\n';
              content += '// Note: All PUBLIC_ variables will be available\n';
              content += 'export const PUBLIC_EXAMPLE = process.env.PUBLIC_EXAMPLE;\n';
            } else {
              content += '// Private environment variables\n';
              content += '// Note: All non-PUBLIC_ variables will be available\n';
              content += 'export const EXAMPLE_VAR = process.env.EXAMPLE_VAR;\n';
            }

            return {
              contents: content,
              loader: 'js'
            };
          });
        },
      };

      // Register the plugin
      context.registerPlugin(functionsPlugin);

      // Generate type declarations
      generateFunctionTypeDeclarations(context, fileCache);

      // Add function files as a layer to ensure they're included in the build
      const layerFiles: Record<string, string> = {};
      for (const [filePath, _] of fileCache.entries()) {
        const relativePath = path.relative(context.workingDir, filePath);
        layerFiles[relativePath] = filePath;
      }

      context.addLayer({
        id: "triggerkit-layer",
        files: layerFiles
      });
    }
  };
}

// Helper function to scan a folder recursively for function files
async function scanFolderForFunctions(
  folderPath: string,
  filePatterns: string[],
  excludePatterns: string[],
  fileCache: Map<string, CachedFile>,
  context: any
): Promise<void> {
  try {
    // Read the directory contents
    const entries = await fs.promises.readdir(folderPath, { withFileTypes: true });

    for (const entry of entries) {
      const entryPath = path.join(folderPath, entry.name);

      // Skip entries that match exclude patterns
      if (excludePatterns.some(pattern => entry.name.includes(pattern))) {
        continue;
      }

      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        await scanFolderForFunctions(entryPath, filePatterns, excludePatterns, fileCache, context);
      } else if (entry.isFile()) {
        // Check if the file matches our patterns
        const hasMatchingExtension = filePatterns.some(ext => entry.name.endsWith(ext));

        if (hasMatchingExtension) {
          // Get file stats to check modification time
          const fileStats = fs.statSync(entryPath);
          const currentLastModified = fileStats.mtimeMs;

          const existingCache = fileCache.get(entryPath);

          // Check if the file has been modified since last build
          if (!existingCache || currentLastModified !== existingCache.lastModified) {
            context.logger.log(`Found or updated function file: ${entryPath}`);

            try {
              const content = fs.readFileSync(entryPath, 'utf-8');

              // Transform SvelteKit environment imports
              const transformedContent = transformSvelteKitEnvImports(content);

              // Only cache if it has exported functions
              const hasFunctions = extractFunctionNames(transformedContent).length > 0;

              if (hasFunctions) {
                fileCache.set(entryPath, {
                  path: entryPath,
                  lastModified: currentLastModified,
                  content: transformedContent
                });
              }
            } catch (error) {
              context.logger.warn(`Error reading file ${entryPath}:`, error);
            }
          } else {
            context.logger.log(`Using cached version of: ${entryPath}`);
          }
        }
      }
    }
  } catch (error) {
    context.logger.warn(`Error scanning folder ${folderPath}:`, error);
  }
}

// Helper function to transform SvelteKit env imports to use process.env
function transformSvelteKitEnvImports(source: string): string {
  // Transform imports from $env/static/public or $env/static/private
  return source.replace(
    /import\s+\{\s*([^}]+)\s*\}\s+from\s+['"](\$env\/static\/(?:public|private))['"]/g,
    (match: string, imports: string, modulePath: string) => {
      const isPublic = modulePath.endsWith('public');
      const envType = isPublic ? 'public' : 'private';

      // Keep track of the original import for debugging
      const originalImport = match;

      // Parse the imported variables
      const variables = imports.split(',').map(v => v.trim());

      // Add a comment with the original import for reference
      let result = `// Original: ${originalImport.trim()}\n`;
      result += `// Transformed $env/static/${envType} imports\n`;

      // Generate process.env assignments for each variable
      const processEnvAssignments = variables
        .map(varName => `const ${varName} = process.env.${varName};`)
        .join('\n');

      return result + processEnvAssignments;
    }
  );
}

// Helper function to extract exported function names from a file
function extractFunctionNames(content: string): string[] {
  const functionNames: string[] = [];

  // Match exported functions (both regular and arrow functions)
  const exportedFunctionRegex = /export\s+(async\s+)?function\s+([a-zA-Z0-9_]+)/g;
  const exportedArrowFunctionRegex = /export\s+const\s+([a-zA-Z0-9_]+)\s*=\s*(async\s+)?\(/g;

  let match;

  // Find standard exported functions
  while ((match = exportedFunctionRegex.exec(content)) !== null) {
    functionNames.push(match[2]);
  }

  // Find exported arrow functions
  while ((match = exportedArrowFunctionRegex.exec(content)) !== null) {
    functionNames.push(match[1]);
  }

  return functionNames;
}

// Generate type declarations for all functions
function generateFunctionTypeDeclarations(
  context: any,
  fileCache: Map<string, CachedFile>
): void {
  try {
    // Build the declaration content
    let declarationContent = `// Generated by triggerkit\n\n`;
    declarationContent += `declare module '${VIRTUAL_MODULE_ID}' {\n`;

    // Group files by folder for better organization
    const filesByFolder: Record<string, string[]> = {};

    // Organize files by folder
    for (const [filePath, cachedFile] of fileCache.entries()) {
      if (!cachedFile.content) continue;

      // Get the relative path from the working directory
      const relPath = path.relative(context.workingDir, filePath);
      // Get the directory for grouping
      const dirName = path.dirname(relPath);

      if (!filesByFolder[dirName]) {
        filesByFolder[dirName] = [];
      }

      filesByFolder[dirName].push(filePath);
    }

    // Process each folder
    for (const [folder, filePaths] of Object.entries(filesByFolder)) {
      declarationContent += `  // Functions from ${folder}\n`;

      // Process each file in the folder
      for (const filePath of filePaths) {
        const cachedFile = fileCache.get(filePath);
        if (!cachedFile || !cachedFile.content) continue;

        const content = cachedFile.content;
        const fileName = path.basename(filePath);

        // Find exported functions
        const exportFunctionRegex = /export\s+(async\s+)?function\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)(?:\s*:\s*([^{]*))?/g;
        const exportArrowFunctionRegex = /export\s+const\s+([a-zA-Z0-9_]+)\s*=\s*(async\s+)?\(\s*([^)]*)\s*\)(?:\s*=>\s*[^{]*|\s*:\s*([^=]*)\s*=>)/g;

        let match;

        // Add comment for the file
        declarationContent += `  // From ${fileName}\n`;

        // Process regular function declarations
        while ((match = exportFunctionRegex.exec(content)) !== null) {
          const isAsync = !!match[1];
          const functionName = match[2];
          const params = match[3] || '';
          const returnType = match[4] ? match[4].trim() : 'any';

          // Add the function declaration
          declarationContent += `  export function ${functionName}(${params})`;

          // Add return type
          if (isAsync) {
            declarationContent += `: Promise<${returnType}>;\n\n`;
          } else {
            declarationContent += `: ${returnType};\n\n`;
          }
        }

        // Process arrow functions
        while ((match = exportArrowFunctionRegex.exec(content)) !== null) {
          const functionName = match[1];
          const isAsync = !!match[2];
          const params = match[3] || '';
          const returnType = match[4] ? match[4].trim() : 'any';

          // Add the function declaration
          declarationContent += `  export function ${functionName}(${params})`;

          // Add return type
          if (isAsync) {
            declarationContent += `: Promise<${returnType}>;\n\n`;
          } else {
            declarationContent += `: ${returnType};\n\n`;
          }
        }
      }
    }

    // Add the functions object
    declarationContent += `  export const functions: Record<string, Function>;\n`;

    // Close the module declaration
    declarationContent += `}\n`;

    // Write to the src directory
    try {
      const srcDeclPath = path.resolve(process.cwd(), `src/virtual-triggerkit.d.ts`);
      fs.writeFileSync(srcDeclPath, declarationContent);
      context.logger.log(`Generated TypeScript declaration file at: ${srcDeclPath}`);
    } catch (error) {
      context.logger.warn(`Error writing declaration file:`, error);
    }
  } catch (error) {
    context.logger.warn(`Error generating TypeScript declaration file:`, error);
  }
}

export { triggerkit, VIRTUAL_MODULE_ID }