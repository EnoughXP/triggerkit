import { normalizePath } from 'vite';
import type { Plugin, HmrContext } from 'vite';
import { resolve } from 'node:path';
import { promises as fs } from 'node:fs';
import fastGlob from 'fast-glob';
import parseFile from '../utils/parser';
import type { ExportedFunction, PluginOptions } from '../types';
import { transformEnvImports } from '../utils';

const VIRTUAL_MODULE_ID = 'virtual:triggerkit';
const VIRTUAL_MODULES_RESOLVED_ID = '\0' + VIRTUAL_MODULE_ID;

export function triggerkit(options: PluginOptions = {}): Plugin {
  const defaultOptions: Required<PluginOptions> = {
    includeDirs: ['src/lib'],
    include: ['**/*.{ts,js}', '**/*.svelte.{ts,js}'],
    exclude: ['**/node_modules/**', '**/*.test.ts', '**/*.spec.ts'],
  };

  const resolvedOptions = { ...defaultOptions, ...options };
  const { includeDirs, include, exclude } = resolvedOptions;
  let resolvedIncludeDirs: string[] = [];
  let exportedFunctions: ExportedFunction[] = [];
  let discoveredEnvVars = new Set<string>();
  const virtualModules = new Map<string, string>();

  const moduleCache = new Map<string, {
    timestamp: number;
    content: string;
  }>();

  async function updateModuleCache(path: string, content: string) {
    moduleCache.set(path, {
      timestamp: Date.now(),
      content
    });
    virtualModules.set(getVirtualId(path), content);
  }

  function getVirtualId(path: string): string {
    return path.startsWith('/') ? `${VIRTUAL_MODULES_RESOLVED_ID}${path.slice(1)}` : `${VIRTUAL_MODULES_RESOLVED_ID}${path}`;
  }

  function shouldProcessFile(id: string): boolean {
    const normalizedId = normalizePath(id);
    return resolvedIncludeDirs.some(dir => {
      if (!normalizedId.startsWith(dir)) return false;

      const relativePath = normalizedId.slice(dir.length);

      const matchesInclude = include.some(pattern =>
        fastGlob.isDynamicPattern(pattern) ?
          new RegExp(fastGlob.convertPathToPattern(pattern)).test(relativePath) :
          relativePath.includes(pattern.replace(/\*/g, ''))
      );

      const matchesExclude = exclude.some(pattern =>
        fastGlob.isDynamicPattern(pattern) ?
          new RegExp(fastGlob.convertPathToPattern(pattern)).test(relativePath) :
          relativePath.includes(pattern.replace(/\*/g, ''))
      );

      return matchesInclude && !matchesExclude;
    });
  }

  async function scanDirectories(): Promise<string[]> {
    const files: string[] = [];

    for (const dir of resolvedIncludeDirs) {
      try {
        await fs.access(dir);
      } catch (error) {
        console.warn(`Directory ${dir} does not exist, skipping...`);
        continue;
      }

      const patterns = include.map(pattern =>
        normalizePath(resolve(dir, pattern))
      );
      const negativePatterns = exclude.map(pattern =>
        `!${normalizePath(resolve(dir, pattern))}`
      );

      const matches = await fastGlob([...patterns, ...negativePatterns], {
        absolute: true,
        dot: true,
        followSymbolicLinks: false,
        onlyFiles: true,
        unique: true,
        cwd: process.cwd()
      });

      files.push(...matches.map(f => normalizePath(f)));
    }

    return files;
  }

  async function scanForFunctions() {
    const files = await scanDirectories();
    exportedFunctions = [];
    discoveredEnvVars.clear();

    for (const file of files) {
      try {
        const stat = await fs.stat(file);
        const cached = moduleCache.get(file);

        if (cached && cached.timestamp >= stat.mtimeMs) {
          // Use cached version if file hasn't changed
          const virtualPath = getVirtualId(file);
          virtualModules.set(virtualPath, cached.content);
          continue;
        }

        const content = await fs.readFile(file, 'utf-8');
        const relativePath = normalizePath(file).replace(process.cwd() + '/', '');
        const { exports, envVars, transformedContent } = parseFile(content, relativePath);

        if (envVars.length > 0) {
          const transformed = transformEnvImports(transformedContent);
          await updateModuleCache(relativePath, transformed);
          envVars.forEach(v => discoveredEnvVars.add(v));
        }

        exportedFunctions.push(...exports);
      } catch (error) {
        console.warn(`Error processing file ${file}: `, error);
      }
    }
  }

  function generateEntryModule() {
    const envVars = [...discoveredEnvVars];

    return `
// Generated by triggerkit
${envVars.length > 0 ? `const { ${envVars.join(', ')} } = process.env;\n` : ''}

// Re-export transformed functions grouped by module
${Object.entries(exportedFunctions.reduce((acc, func) => {
      const virtualPath = getVirtualId(func.path);
      const hasEnvVars = virtualModules.has(virtualPath);
      const importPath = hasEnvVars
        ? `/@id/${virtualPath}`
        : func.path.replace(/^src\/lib\//, '$lib/').replace(/\.ts$/, '');

      if (!acc[importPath]) acc[importPath] = [];
      acc[importPath].push(func.exportName);
      return acc;
    }, {} as Record<string, string[]>))
        .map(([path, exports]) => `export { ${exports.join(', ')} } from '${path}';`)
        .join('\n')}

// Export function metadata
export const functions = ${JSON.stringify(
          exportedFunctions.reduce((acc, func) => ({
            ...acc,
            [func.name]: {
              metadata: func.metadata,
              path: func.path,
              envVars: [...discoveredEnvVars]
            }
          }), {}),
          null,
          2
        )} as const;`;
  }

  return {
    name: 'vite-plugin-triggerkit',
    enforce: 'pre',
    configResolved() {
      const cwd = process.cwd();
      resolvedIncludeDirs = includeDirs.map(dir =>
        normalizePath(resolve(cwd, dir))
      );
    },
    async buildStart() {
      await scanForFunctions();
      virtualModules.set(getVirtualId('entry'), generateEntryModule());
    },
    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return VIRTUAL_MODULES_RESOLVED_ID;
      }
      if (id.startsWith('/@id/' + VIRTUAL_MODULES_RESOLVED_ID)) {
        return id.slice('/@id/'.length);
      }
      return null;
    },
    load(id) {
      if (id === VIRTUAL_MODULES_RESOLVED_ID) {
        return virtualModules.get(getVirtualId('entry'));
      }
      if (virtualModules.has(id)) {
        return virtualModules.get(id);
      }
      return null;
    },
    async handleHotUpdate(ctx: HmrContext) {
      const normalizedFile = normalizePath(ctx.file);
      if (!shouldProcessFile(normalizedFile)) {
        return [];
      }
      return (async () => {
        try {
          const content = await ctx.read();
          const relativePath = normalizedFile.replace(process.cwd() + '/', '');

          const { exports, envVars, transformedContent } = parseFile(content, relativePath);
          const virtualPath = getVirtualId(relativePath);

          if (envVars.length > 0) {
            const transformed = transformEnvImports(transformedContent);
            await updateModuleCache(relativePath, transformed);
            envVars.forEach(v => discoveredEnvVars.add(v));
          } else {
            virtualModules.delete(virtualPath);
            moduleCache.delete(relativePath);
          }

          exportedFunctions = exportedFunctions.filter(fn => fn.path !== relativePath);
          exportedFunctions.push(...exports);
          virtualModules.set(getVirtualId('entry'), generateEntryModule());
        } catch (error) {
          console.warn(`Error updating file ${ctx.file}:`, error);
        }
        return [];
      })();
    }
  };
}