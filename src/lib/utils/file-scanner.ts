import { join } from 'node:path';
import { promises as fs } from 'node:fs';
import { normalizePath } from 'vite';
import parseFile from './parser';

async function scanDirectory(
  dir: string,
  include: string[],
  exclude: string[]
): Promise<string[]> {
  const files: string[] = []

  async function traverse(currentPath: string) {
    const entries = await fs.readdir(currentPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(currentPath, entry.name);
      const relativePath = normalizePath(fullPath).replace(normalizePath(process.cwd()) + '/', '');

      // Skip excluded paths
      if (exclude.some(pattern => relativePath.includes(pattern.replace('!', '')))) {
        continue;
      }

      if (entry.isDirectory()) {
        await traverse(fullPath);
      } else if (entry.isFile()) {
        // Check if file matches include patterns
        if (include.some(pattern => {
          // Convert glob pattern to regex
          const regexPattern = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*');
          return new RegExp(regexPattern).test(relativePath);
        })) {
          files.push(normalizePath(fullPath));
        }
      }
    }
  }

  await traverse(dir);
  return files;
}


export async function scanDirectories(
  resolvedIncludeDirs: string[],
  include: string[],
  exclude: string[]
): Promise<string[]> {
  const allFiles: string[] = [];

  for (const dir of resolvedIncludeDirs) {
    try {
      await fs.access(dir);
      const dirFiles = await scanDirectory(dir, include, exclude);
      allFiles.push(...dirFiles);
    } catch (error) {
      console.warn(`Directory ${dir} does not exist, skipping...`);
    }
  }

  return allFiles;
}

export async function scanForFunctions(
  resolvedIncludeDirs: string[],
  include: string[],
  exclude: string[]
) {
  const files = await scanDirectories(resolvedIncludeDirs, include, exclude);
  const exportedFunctions = [];
  const discoveredEnvVars = new Set<string>();

  for (const file of files) {
    try {
      const content = await fs.readFile(file, 'utf-8');
      const relativePath = normalizePath(file).replace(process.cwd() + '/', '');
      const { exports, envVars } = parseFile(content, relativePath);

      if (envVars.length > 0) {
        envVars.forEach(v => discoveredEnvVars.add(v));
      }

      exportedFunctions.push(...exports);
    } catch (error) {
      console.warn(`Error processing file ${file}: `, error);
    }
  }

  return { exportedFunctions, discoveredEnvVars };
}

export function generateEntryModule(
  exportedFunctions: any[],
  discoveredEnvVars: Set<string>
) {
  const envVars = [...discoveredEnvVars];

  return `
// Generated by triggerkit
${envVars.length > 0 ? `const { ${envVars.join(', ')} } = process.env;\n` : ''}

// Re-export transformed functions grouped by module
${Object.entries(exportedFunctions.reduce((acc, func) => {
    const importPath = func.path.replace(/^src\/lib\//, '$lib/').replace(/\.ts$/, '');

    if (!acc[importPath]) acc[importPath] = [];
    acc[importPath].push(func.exportName);
    return acc;
  }, {} as Record<string, string[]>))
      .map(([path, exports]) => `export { ${exports.join(', ')} } from '${path}';`)
      .join('\n')}

// Export function metadata
export const functions = ${JSON.stringify(
        exportedFunctions.reduce((acc, func) => ({
          ...acc,
          [func.name]: {
            metadata: func.metadata,
            path: func.path,
            envVars: [...discoveredEnvVars]
          }
        }), {}),
        null,
        2
      )} as const;`;
}