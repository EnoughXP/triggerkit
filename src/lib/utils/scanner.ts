import path from 'node:path';
import fs from 'node:fs';
import parseFile from './parser.js';
import type { ExportedFunction, ParseResult } from '$lib/types/index.js';
import { VIRTUAL_MODULE_ID } from './constants.js';

/**
 * Normalize file paths to use forward slashes consistently
*/
function normalizePath(filepath: string): string {
  return filepath.replace(/\\/g, '/');
}

/**
 * Scan a single directory for files matching the patterns
 */
async function scanDirectory(
  dir: string,
  includePatterns: string[],
  excludePatterns: string[],
  context: any
): Promise<string[]> {
  const files: string[] = [];
  context.logger.log(`Scanning directory: ${dir}`);

  // Check if pattern matches a file (simple pattern matching)
  function matchesPattern(filepath: string, patterns: string[]): boolean {
    const normalizedPath = normalizePath(filepath);

    return patterns.some(pattern => {
      // Simple case: direct extension match (e.g., *.ts)
      if (pattern.startsWith('*.') && normalizedPath.endsWith(pattern.substring(1))) {
        return true;
      }

      // Simple case: specific file pattern (e.g., **/*.ts)
      if (pattern.includes('**')) {
        const extension = pattern.split('.').pop() || '';
        return normalizedPath.endsWith(`.${extension}`);
      }

      // Fallback: simple includes check
      return normalizedPath.includes(pattern.replace('**/', '').replace('*', ''));
    });
  }

  // Check if file should be excluded
  function shouldExclude(filepath: string): boolean {
    return matchesPattern(filepath, excludePatterns);
  }

  // Check if file should be included
  function shouldInclude(filepath: string): boolean {
    return matchesPattern(filepath, includePatterns);
  }

  // Recursive function to traverse directories
  async function traverse(currentPath: string): Promise<void> {
    try {
      const entries = await fs.promises.readdir(currentPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(currentPath, entry.name);
        const relativePath = normalizePath(fullPath).replace(normalizePath(process.cwd()) + '/', '');

        // Skip excluded paths
        if (shouldExclude(relativePath)) {
          continue;
        }

        if (entry.isDirectory()) {
          // Recursively traverse subdirectories
          await traverse(fullPath);
        } else if (entry.isFile() && shouldInclude(relativePath)) {
          // Add matching files to the result
          files.push(fullPath);
        }
      }
    } catch (error) {
      context.logger.warn(`Error traversing directory ${currentPath}:`, error);
    }
  }

  try {
    // Check if directory exists before traversing
    await fs.promises.access(dir, fs.constants.R_OK);
    await traverse(dir);
  } catch (error) {
    context.logger.warn(`Cannot access directory ${dir}:`, error);
  }

  return files;
}

/**
 * Scan multiple directories for exportable functions
 */
export async function scanDirectories(
  includeDirs: string[],
  includePatterns: string[],
  excludePatterns: string[],
  context: any
): Promise<ParseResult[]> {
  const results: ParseResult[] = [];
  const allFiles: string[] = [];

  // Scan each include directory
  for (const dir of includeDirs) {
    try {
      const files = await scanDirectory(dir, includePatterns, excludePatterns, context);
      allFiles.push(...files);

      context.logger.log(`Found ${files.length} matching files in ${dir}`);
    } catch (error) {
      context.logger.warn(`Error scanning directory ${dir}:`, error);
    }
  }

  // Process each file
  for (const filePath of allFiles) {
    try {
      // Read the file content
      const fileContent = await fs.promises.readFile(filePath, 'utf-8');

      // Parse the file
      const parseResult = parseFile(fileContent, filePath);
      results.push(parseResult);
    } catch (error) {
      context.logger.warn(`Error processing file ${filePath}:`, error);
    }
  }

  return results;
}

/**
 * Generate the virtual module content
 */
export function generateVirtualModule(
  exportedFunctions: ExportedFunction[],
  envVars: string[]
): string {
  // Start building the module content
  let moduleContent = '// Generated by triggerkit\n\n';

  // Add environment variable declarations
  if (envVars.length > 0) {
    moduleContent += '// Environment variables\n';

    for (const envVar of envVars) {
      moduleContent += `const ${envVar} = process.env.${envVar};\n`;
    }

    moduleContent += '\n';
  }

  // Add imports for each function grouped by file
  moduleContent += '// Function imports\n';
  const importedFunctionsByFile: Record<string, ExportedFunction[]> = {};

  for (const func of exportedFunctions) {
    const filePath = func.path;

    if (!importedFunctionsByFile[filePath]) {
      importedFunctionsByFile[filePath] = [];
    }

    importedFunctionsByFile[filePath].push(func);
  }

  // Generate import statements
  for (const [filePath, functions] of Object.entries(importedFunctionsByFile)) {
    // Convert absolute path to relative import path
    const importPath = path.relative(process.cwd(), filePath)
      .replace(/\\/g, '/') // Convert backslashes to forward slashes
      .replace(/\.ts$|\.js$/, ''); // Remove extension

    // Format the imports - group functions from the same file
    const functionNames = functions.map(f => f.name).join(', ');
    moduleContent += `import { ${functionNames} } from '${importPath}';\n`;
  }

  moduleContent += '\n// Export all functions\n';

  // Re-export functions grouped by file
  for (const [filePath, functions] of Object.entries(importedFunctionsByFile)) {
    const functionNames = functions.map(f => f.name).join(', ');
    moduleContent += `export { ${functionNames} };\n`;
  }

  // Export a functions object for easier consumption
  moduleContent += '\n// Export as an object for easier consumption\n';
  moduleContent += 'export const functions = {\n';

  for (const func of exportedFunctions) {
    moduleContent += `  ${func.name},\n`;
  }

  moduleContent += '};\n';

  return moduleContent;
}

/**
 * Generate a TypeScript declaration file for the virtual module
 */
export function generateTypeDeclaration(
  exportedFunctions: ExportedFunction[],
  context: any,
  outputPath?: string
): void {
  try {
    // Start building the declaration file
    let declarationContent = `// Generated by triggerkit\n\n`;
    declarationContent += `declare module '${VIRTUAL_MODULE_ID}' {\n`;

    // Add function declarations
    for (const func of exportedFunctions) {
      // Add JSDoc if available
      if (func.metadata.docstring) {
        // Convert JSDoc to proper format
        const formattedDocstring = func.metadata.docstring
          .split('\n')
          .map(line => `  ${line}`)
          .join('\n');

        declarationContent += `${formattedDocstring}\n`;
      }

      // Build parameter list with types
      const params = func.metadata.parameters.map(param => {
        const paramType = param.type || 'any';
        return `${param.name}${param.optional ? '?' : ''}: ${paramType}`;
      }).join(', ');

      // Add return type
      const returnType = func.metadata.returnType || 'any';
      const asyncPrefix = func.metadata.isAsync ? 'Promise<' : '';
      const asyncSuffix = func.metadata.isAsync ? '>' : '';

      // Export function declaration
      declarationContent += `  export function ${func.name}(${params}): ${asyncPrefix}${returnType}${asyncSuffix};\n\n`;
    }

    // Add the functions object type
    declarationContent += `  export const functions: {\n`;
    for (const func of exportedFunctions) {
      // Build parameter list with types
      const params = func.metadata.parameters.map(param => {
        const paramType = param.type || 'any';
        return `${param.name}${param.optional ? '?' : ''}: ${paramType}`;
      }).join(', ');

      // Add return type
      const returnType = func.metadata.returnType || 'any';
      const asyncPrefix = func.metadata.isAsync ? 'Promise<' : '';
      const asyncSuffix = func.metadata.isAsync ? '>' : '';

      declarationContent += `    ${func.name}: (${params}) => ${asyncPrefix}${returnType}${asyncSuffix};\n`;
    }
    declarationContent += `  };\n`;

    // Close the module declaration
    declarationContent += `}\n`;

    // Write the declaration file to the project root or build directory
    const typesDir = path.resolve(process.cwd(), 'src/types');
    if (!fs.existsSync(typesDir)) {
      fs.mkdirSync(typesDir, { recursive: true });
    }

    const declarationPath = path.resolve(typesDir, 'virtual-triggerkit.d.ts');
    fs.writeFileSync(declarationPath, declarationContent);

    context.logger.log(`Generated TypeScript declaration file at: ${declarationPath}`);

    if (outputPath) {
      // Make sure the directory exists
      const dir = path.dirname(outputPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(outputPath, declarationContent);
      context.logger.log(`Also wrote declaration file to: ${outputPath}`);
    }
  } catch (error) {
    context.logger.warn(`Error generating TypeScript declaration file:`, error);
  }
}