import { join } from 'node:path';
import { promises as fs } from 'node:fs';
import { normalizePath } from 'vite';
import parseFile from './parser.js';
import type { ExportedFunction } from '$lib/types/index.js';

async function scanDirectory(
  dir: string,
  include: string[],
  exclude: string[]
): Promise<string[]> {
  const files: string[] = [];
  console.log(`[triggerkit] Scanning directory: ${dir}`);

  async function traverse(currentPath: string) {
    const entries = await fs.readdir(currentPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(currentPath, entry.name);
      const relativePath = normalizePath(fullPath).replace(normalizePath(process.cwd()) + '/', '');

      // Skip node_modules and other excluded patterns (simple string check)
      if (exclude.some(pattern => relativePath.includes(pattern.replace('**/', '')))) {
        continue;
      }

      if (entry.isDirectory()) {
        await traverse(fullPath);
      } else if (entry.isFile()) {
        // Check if the file extension matches any of the include patterns
        const matchesInclude = include.some(pattern => {
          const fileExtension = pattern.split('.').pop() || '';
          return entry.name.endsWith(fileExtension) &&
            !entry.name.includes('.test.') &&
            !entry.name.includes('.spec.');
        });

        if (matchesInclude) {
          files.push(normalizePath(fullPath));
        } else {
          console.log(`[triggerkit] Skipping file (not matching include patterns): ${relativePath}`);
        }
      }
    }
  }

  await traverse(dir);
  return files;
}
async function scanDirectories(
  resolvedIncludeDirs: string[],
  include: string[],
  exclude: string[]
): Promise<string[]> {
  const allFiles: string[] = [];

  for (const dir of resolvedIncludeDirs) {
    try {
      await fs.access(dir);
      const dirFiles = await scanDirectory(dir, include, exclude);
      allFiles.push(...dirFiles);
    } catch (error) {
      console.warn(`Directory ${dir} does not exist, skipping...`);
    }
  }

  return allFiles;
}

export async function scanForFunctions(
  resolvedIncludeDirs: string[],
  include: string[],
  exclude: string[],
) {
  console.log(`[triggerkit] Scanning directories: ${resolvedIncludeDirs.join(', ')}`);
  const files = await scanDirectories(resolvedIncludeDirs, include, exclude);

  if (files.length > 0) {
    console.log(`[triggerkit] Files to scan: ${files.join('\n')}`);
  }

  const exportedFunctions = [];
  const discoveredEnvVars = new Set<string>();

  for (const file of files) {
    try {

      const content = await fs.readFile(file, 'utf-8');
      const relativePath = normalizePath(file).replace(normalizePath(process.cwd()) + '/', '');

      // Modified to parse all files regardless of annotations
      const { exports, envVars } = parseFile(content, relativePath); // Pass false to indicate no annotation requirement

      if (exports.length > 0) {
        console.log(`[triggerkit] Exports: ${exports.map(e => e.name).join(', ')}`);
      }

      if (envVars.length > 0) {
        envVars.forEach(v => discoveredEnvVars.add(v));
      }

      exportedFunctions.push(...exports);
    } catch (error) {
      console.warn(`[triggerkit] Error processing file ${file}: `, error);
    }
  }

  return { exportedFunctions, discoveredEnvVars };
}

export function generateEntryModule(
  exportedFunctions: ExportedFunction[],
  discoveredEnvVars: Set<string>
): string {
  const envVars = [...discoveredEnvVars];

  // Group functions by their source file
  const functionsByPath = exportedFunctions.reduce((acc, func) => {
    // Convert absolute path to path relative to project root
    const relativePath = func.path.replace(process.cwd() + '/', '');

    // If the path starts with src/, remove it
    const adjustedPath = relativePath.startsWith('src/')
      ? relativePath.slice(4)  // Remove 'src/' prefix
      : relativePath;

    // Remove .ts extension
    const importPath = adjustedPath.replace(/\.ts$/, '');

    if (!acc[importPath]) acc[importPath] = [];
    acc[importPath].push(func.exportName);
    return acc;
  }, {} as Record<string, string[]>);

  return `
// Auto-generated by triggerkit
// Current working dir: ${process.cwd()}
// DO NOT EDIT
${envVars.length > 0 ? `const { ${envVars.join(', ')} } = process.env;\n` : ''}

// Re-export transformed functions grouped by module
${Object.entries(functionsByPath)
      .map(([path, exports]) => `export { ${exports.join(', ')} } from '../${path}';`)
      .join('\n')}

// Export function metadata
export const functions = ${JSON.stringify(
        exportedFunctions.reduce((acc, func) => ({
          ...acc,
          [func.name]: {
            metadata: func.metadata,
            path: func.path,
            envVars: [...discoveredEnvVars]
          }
        }), {}),
        null,
        2
      )} as const;`;
}